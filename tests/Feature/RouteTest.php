<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;
use Route;

class RouteTest extends TestCase
{
    /**
     * Testing Application Routes
     *
     * @return void
     */
    public function testExample()
    {
        $status_codes = [
            100 => "Continue. The client SHOULD continue with its request. This interim response is used to inform the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed. See section 8.2.3 for detailed discussion of the use and handling of this status code.",

            101 => "Switching Protocols. The server understands and is willing to comply with the client's request, via the Upgrade message header field (section 14.42), for a change in the application protocol being used on this connection. The server will switch protocols to those defined by the response's Upgrade header field immediately after the empty line which terminates the 101 response.",

            200 => "OK. The request has succeeded. With GET an entity corresponding to the requested resource is sent in the response; With HEAD the entity-header fields corresponding to the requested resource are sent in the response without any message-body; With POST an entity describing or containing the result of the action; With TRACE an entity containing the request message as received by the end server.",

            201 => "Created. The request has been fulfilled and resulted in a new resource being created. The newly created resource can be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header field.",

            201 => "Response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 14.19.",

            202 => "Accepted. The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. The entity returned with this response SHOULD include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.",

            300 => "Multiple Choices. The requested resource corresponds to any one of a set of representations, each with its own specific location, and agent- driven negotiation information (section 12) is being provided so that the user (or user agent) can select a preferred representation and redirect its request to that location.",

            301 => "Moved Permanently. The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs.",

            302 => "Found. The requested resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client SHOULD continue to use the Request-URI for future requests.",

            303 => "See Other. The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script to redirect the user agent to a selected resource. ",

            304 => "Not Modified. If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code. ", 

            305 => "Use Proxy. The requested resource MUST be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers.",

            307 => "Temporary Redirect. The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on occasion, the client SHOULD continue to use the Request-URI for future requests.",

            400 => "Bad Request. The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.",

            401 => "Unauthorized. The request requires user authentication.",

            402 => "Payment Required. This code is reserved for future use.",

            403 => "Forbidden. The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated.",

            404 => "Not Found. The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows.",

            405 => "Method Not Allowed. The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource.",

            406 => "Not Acceptable. The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.",

            500 => "Internal Server Error. The server encountered an unexpected condition which prevented it from fulfilling the request.",
            501 => "Not Implemented. The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.",
            502 => "Bad Gateway. The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.",
            503 => "Service Unavailable. The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay.",
            504 => "Gateway Timeout. The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request.",
            505 => "HTTP Version Not Supported. The server does not support, or refuses to support, the HTTP protocol version that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in section 3.1, other than with this error message."
    ];
        $appURL = env('APP_URL');
        
        $urls = Route::getRoutes();
        
        $skip = [
            "laravel-websockets",
            "laravel-websockets/api/{appId}/statistics",
            'graphql',
            'graphiql/{default}',
            'img/cache/{template}/{filename}',
            '_ignition/scripts/{script}',
            '_ignition/styles/{style}',
            'setup/optimize',
            'setup/seed',
            'setup/migrate',
            'setup/rollback',
            'logs',
            'setup/table/{action}/{table}',
            'setup/reset',
            'setup/terminal',
            'test'
        ];
        
        $replace = [
            "graphql/{default}" => "graphql?query={viewer{user}}"
        ];

        echo  PHP_EOL;

        foreach ($urls as $url) {
            $uri = $url->uri();

            if(in_array("GET", $url->methods()) && !in_array($uri, $skip)){
                
                if(isset($replace[$uri])){
                    $uri = $replace[$uri];
                }

                $response = $this->get($uri);

                if((int)$response->status() >= 500){
                    echo  $uri . ' (FAIL) ' . 
                        $response->status() . ' ' . 
                        $status_codes[$response->status()] . 'methods: ' . 
                        json_encode($url->methods());
                        
                        if($response->status() >= 500){
                           preg_match('/<title>([^\<])*<\/title>/', $response->getContent(), $matches);   
                           if(isset($matches[0])){echo $matches[0];}
						}else{
                            echo count($matches);
						}
 
                    $this->assertTrue(false); 

                } else {
                    echo $uri . ' (success ?) ' . $response->status() . ' code';
                    $this->assertTrue(true); 
                }

                 echo  PHP_EOL;
            }
            
           
        }

    }
}
